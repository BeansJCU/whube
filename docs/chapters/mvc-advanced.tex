\chapter{Digging in deeper to Whube}
In this chapter we will discuss more advanced features of the Whube platform.
\section{\$SITE\_PREFIX}
This is the full URL Path ( INCLUDING \texttt{http://} ) to the server and ending with
a trailing slash ( IMPORTANT! ). ALWAYS use this when refering to another whube project file.
If you fail to do this, it WILL fail. When you don't know the absolute path ( how many arguments
were passed into the script ) you don't know how many times to call \texttt{../}!! Failing to use \$SITE\_PREFIX
will cause your code to be rejected without review.
\section{Kicking ass with \$argv}
Let's take a look at a new request. \texttt{http://whube.com/t/foo/bar/baz}.
Breaking this back up, the request turns into \texttt{controller.php?p=foo/bar/baz}.
If you missed this, go back and review the MVC Basics. \texttt{controller.php} will
strip out the first item ( \texttt{foo} ) to detect the content script. \texttt{content.php}
will take the rest of the URL past a forward slash and put it into an argument list.
\texttt{content.php} sets up \$argv and \$argc just like this:
\begin{verbatim}

    // handling request http://whube.com/t/foo/bar/baz

    $argv = array(   // it's not actually done this way
        'bar',       // but it makes things really clear
        'baz'        // compared to the push back system
    );               // it uses.

    $argc = sizeof( $argv ); // this is actually how it's done.

\end{verbatim}
A simple script using this would look something like:
\begin{verbatim}
<?php
    $TITLE   = 'Argument Listing';
    $CONTENT = "<h1>Arguments passed in:</h1>\n";

    foreach( $argv as $arg ) {
        $CONTENT .= $arg . "<br />\n";
    }

?>
\end{verbatim}
If the foreach loop is new to you, you are missing out! It's really
handy if you want to avoid cookiecutter code like a normal for loop.
\section{Pimping out with useScript()}
\texttt{useScript()} is a pretty kickass function of the whube codebase.
It does lots of really fun things when you wish to manage what scripts should be included.
When you call \texttt{useScript("jQuery.js");} it does some nifty stuff under the hood.
It pushes the identifer back in an array \texttt{\$SCRIPT}. When the \texttt{view/view.php}
script is called, the \texttt{view/head.php} script should go through the \texttt{\$SCRIPT}
array and echo out the full path to the script with the correct base.\\
\\
\\
\texttt{useScript("jQuery.js");} \\ will produce output that looks a bit like \\
\\
\texttt{<script src = 'http://whube.com/libs/js/jQuery.js' type = 'text/javascript'></script>}
The bit \texttt{http://whube.com/} will of course, be replaced with \texttt{\$SITE\_PREFIX}.
This also allows for the \texttt{useScript()} to rewrite URLs on the fly, and handle conditionals
outside of the view ( content ) code.
\section{Using the models}
The core of what makes Whube easy to use is the \texttt{dbobj} superclass, and all the
models that inherit from that. \texttt{dbobj} provides a unified object interface to the
Whube backend. It provides a lot of methods that take pre-templated SQL querys and generlizes them.
Let's take a look at a basic listing example for all bugs, and also querys projects and users.
\begin{verbatim}

<?php
    $Count = 20; // How many bugs we want on the page

    include( "model/bug.php" );       // Home of the bug klass
    include( "model/user.php" );      // Home of the user klass
    include( "model/project.php" );   // Home of the project klass

    $b = new bug(); // instantiate bug klass
    $b->getAll();   // same as a SELECT * FROM bugs;

    $u = new user();     // instantiate user klass
    $p = new project();  // instantiate project klass

    $TITLE = "Latest $Count bugs"; // descriptive title

    $i = 0; // Oldschool C99 style.

    $CONTENT .= "
<table>
    <tr>
        <th>ID</th> <th>Owner</th> <th>Project</th> <th>Title</th>
    </tr>
"; // Basic HTML code to start off the loop.

    while ( $row = $b->getNext() ) { // while we have bugs to go thru

        $u->getAllByPK( $row['owner'] );
        // ^ same as: SELECT * FROM users WHERE uID = '$OWNER';

        /*
         * You can see how easy it is to forget a col name here
         * or a table name there. Not if you use the models. Not
         * to mention you won't have to rewrite every Query if
         * you need to move a table or something.
         *
         */

        $owner = $u->getNext();
        // Get the first row ( should only be one ) 

        $p->getAllByPK( $row['package'] );
        // ^ same as: SELECT * FROM projects WHERE pID = '$PACKAGE';
        $package = $p->getNext(); // should only be one :)

        if ( $i < $Count ) { // check to see if we need another bug
            $CONTENT .= "\t<tr>\n<td>" . $row['bID'] // This is just
                . "</td><td>"                        // Display code.
                    . $owner['real_name']            // just outputs
                . "</td><td>"                        // a single line
                    . $package['project_name']       // of the table
                . "</td><td><a href = '"
                    . $SITE_PREFIX . "t/bug/" . $row['bID']
                . "' >" . $row['title']
                . "</a></td>\n\t</tr>\n";
        } else {
            break; // leave the while loop if we are > $Count
        }
        $i++;
    }

    $CONTENT .= "
</table><br /><br />
"; // end the basic HTML stuff

?>
\end{verbatim}
You can see how it's easy to search for an object by it's internal ID.
